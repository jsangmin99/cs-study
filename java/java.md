## Java

<details>
<summary>📚 공부한 자료</summary>

- 자바의 정석

</details>

### 1. JVM이 정확히 무엇이고, 어떤 기능을 하는지 설명해 주세요. ⭐️
  - 자바 가상 머신은 자바와 운영체제 사이에서 중개자 역할을 합니다. 따라서 운영체제와 상관없이 독립적으로 실행할수있다는 장점이 있습니다.
  - 자바 소스코드는 먼저 바이트 코드로 변환이되고 JVM 위에서 실행됩니다.
  - 주요 기능은 메모리 관리와 가비지 컬렉터가 있습니다.
  ---
- **그럼, 자바 말고 다른 언어는 JVM 위에 올릴 수 없나요?**
  - 올릴수 있습니다. Kotlin, Scala, Groovy라는 언어도 JVM 위에서 실행시킬수 있습니다.

- **반대로 JVM 계열 언어를 일반적으로 컴파일해서 사용할 순 없나요?**
  - 보통 JVM컴파일러를 사용하여 컴파일을 합니다. 하자면 GraalVM 을 사용하여 다른 언어들을 JVM 바이트 코드로변환하여 사용할수있습니다.
  - 코틀린의 경우 Kotlin Native 컴파일러를 사용하여 기계어로 컴파일할 수 있다.
  - 그러나 JVM은 바이트코드를 실행하는데 최적화되어 있으므로 기계어로 컴파일하는 것이 권장되지 않는다.

- **JVM과 내부에서 실행되고 있는 프로그램은 부모 프로세스 - 자식 프로세스 관계를 갖고 있다고 봐도 무방한가요?**
  - JVM은 하나의 독립적인 프로세스이며, 내부에서 동작하는 자바 애플리케이션은 스레드를 사용하여 처리합니다.
  - 따라서 부모 프로세스 - 자식 프로세스 관계가 아니라 단일 프로세스 - 스레드 관계이다.


- **Java bytecode란 무엇인가요?**
  - Java 바이트코드는 자바 소스 코드를 컴파일한 결과물로 JVM에서 실행 가능한 중간 언어입니다. 
  - 자바 컴파일러는 자바 소스 코드를 바이트코드로 변환하여 .class 파일로 저장합니다. 
  - 이 바이트코드는 JVM이 이해할 수 있는 형식으로 운영체제에 독립적인 실행 환경을 제공합니다.

- **그렇다면 Java는 컴파일 언어일까요, 인터프리터 언어일까요?**
  - 자바는 컴파일과 인터프리터의 혼합형 언어입니다 자바는 먼저 자바 소스 코드를 바이트코드로 컴파일하고 이후 JVM이 그 바이트코드를 인터프리터 방식으로 실행합니다

- **JVM의 동작 방식에 대해 간단하게 설명해주세요.**
  1. 자바 소스코드를 바이트 코드로 변환
  2. 로드: JVM은 자바 바이트코드를 메모리에 로드합니다.
  3. 실행: JVM은 바이트코드를 해석하고 실행합니다. 이때 JIT(Just-In-Time) 컴파일러가 바이트코드를 네이티브 코드로 변환하여 실행 성능을 최적화할 수 있습니다.

- **JVM의 구조에 대해 설명해주세요.**
  - 클래스 로더: 바이트코드 파일을 JVM 메모리로 로드합니다.
  - 실행 엔진: 바이트코드를 실행하며, 인터프리터 방식 또는 JIT 컴파일러를 통해 실행합니다.
  - 런타임 데이터 영역: JVM이 실행 중인 프로그램에 필요한 데이터를 저장하는 메모리 영역입니다.
  - 가비지 컬렉션: 메모리 관리 시스템으로, 더 이상 사용되지 않는 객체를 자동으로 제거합니다.

- **JVM의 Runtime Data Area 영역은 무엇인가요?**
  - JVM의 런타임 데이터 영역은 프로그램이 실행될 때 사용하는 메모리 영역입니다.
    - 메소드 영역: 클래스 관련 데이터(클래스의 구조, 상수, 메소드 등)를 저장합니다.
    - 힙 영역: 객체를 저장하는 공간으로, 가비지 컬렉션이 관리합니다.
    - 스택 영역: 각 스레드마다 별도의 스택이 할당되며, 메서드 호출 시 로컬 변수와 파라미터가 저장됩니다.
    - PC 레지스터: 현재 실행 중인 명령어의 주소를 추적합니다.
    - 네이티브 메소드 스택: 네이티브 메소드를 실행하는 데 사용되는 스택입니다.

- **JVM Stack 과 Heap 영역의 가장 큰 차이점은 무엇인가요?**
  - 메모리 관리 입니다.
  - 스택(Stack): 메서드 호출 시 생성되는 로컬 변수와 메서드 정보를 저장합니다. 각 스레드마다 독립적인 스택을 가지고 있으며, 메서드가 종료되면 자동으로 할당된 메모리가 해제됩니다.
  - 힙(Heap): 객체와 배열을 저장하는 영역으로, JVM에서 가비지 컬렉터에 의해 관리됩니다. 스택과 달리, 힙의 객체는 메서드가 종료되어도 사라지지 않습니다.

- **만약 두 개의 스레드가 동시에 힙에 있는 메모리에 접근할 때 동시성 문제가 생길 수 있습니다. 구체적인 예시로는 어떤 것이 있을까요?**
  ```java
  public class Main {
    private int count = 0;

    public void increment() {
        count++;
    }
  }
  ```
  - increment를 여러 쓰레드에서 실행 시킬때 동시성 문제로 값이 정확하게 증가하지 않을 수도 있습니다.

- **스레드이 메서드별로 스택이 할당 되는데, 메서드가 종료되게 되면 그 메서드 안에서 아용된 로컬 변수가 쓸모 없어지기 때문에 메모리 해제가 되는데, 만약 메서드 안에서 선언한 변수가 참조형 타입인 경우에는 어떤 식으로 메모리가 사용되나요?**
  - 메서드 안에서 선언된 참조형 타입 변수는 스택에 저장되지만, 이 변수 자체는 참조를 저장하는 메모리 공간입니다. 객체는 힙 영역에 할당되며, 메서드가 종료되면 스택에서 참조가 제거됩니다. 만약 다른 곳에서 그 객체를 참조하고 있다면, 그 객체는 힙에 남아 있게 되며, 가비지 컬렉터에 의해 제거되지 않습니다.

- **Java 메모리 영역 중 Stack 과 Heap 에는 각각 어떤 것이 저장되나요?**
  - 스택(Stack): 각 스레드의 로컬 변수, 메서드 호출 정보, 파라미터 등이 저장됩니다.
  - 힙(Heap): 모든 객체와 배열이 저장됩니다.

- **기본형 데이터 타입과 참조형 데이터 타입의 실제 값은 각각 어느 영역에 저장되나요?**
  - 기본형 데이터 타입: 변수 자체의 값이 스택에 저장됩니다.
  - 참조형 데이터 타입: 객체의 참조 주소가 스택에 저장되며, 객체 자체는 힙에 저장됩니다.

- **그렇다면, `Person p = new Person()` 를 실행했을 때 `p` 와 `Person() 객체` 는 각각 어느 영역에 저장되나요?**
  - p는 스택에 저장되며, Person() 객체는 힙에 저장됩니다. p는 객체의 참조 주소를 가지고 있으며, 이 주소는 힙에 저장된 객체를 가리킵니다.

- **Java 메모리의 있는 스택 프레임은 메서드가 종료되면 사라집니다. 하지만 힙 영역에 있는 객체들은 메서드가 종료되도 메모리에 남아 있습니다. 왜 그럴까요?**
  - 스택 프레임은 메서드 호출과 관련된 정보만 저장되며, 메서드가 종료되면 해당 정보도 사라집니다. 그러나 힙에 저장된 객체들은 메서드 호출과 관계없이 계속 유지됩니다. 객체가 가비지 컬렉션에 의해 제거되지 않는 한 힙에 남아 있게 됩니다.


- **Static 영역과 Heap 영역의 공통점과 차이점은 무엇인가요?**
  - 공통점: 두 영역 모두 객체나 데이터를 저장할 수 있습니다.
  - 차이점:Static 영역은 클래스의 정적 변수와 정적 메서드를 저장하며, 프로그램 전체에서 공용으로 사용됩니다.힙은 동적 객체와 배열이 저장됩니다. 객체는 생성 시 동적으로 메모리 할당됩니다.


### 2. final 키워드를 사용하면, 어떤 이점이 있나요?
  - 불변성을 보장하서나 상속, 오버라딩을 제한하기 위해 사용됩니다.
  - 값이 변경되는것을 막기위해 불변성을 보장하거나ㅇ메서드나 클래스의 동작이 의도하지 않도록 사용을 막기위해 사용합니다.
  - JIT 컴파일러에 최적화 되어 final로 선언된 변수는 값이 변경되지 않으므로 컴파일러가 이값을 상수로 간주하고 최적화를 수행할수있습니ㅏㄷ. 그리고 메서드가 final 일경우에는 메서드 호출을 인라인으로 대체할 가능성이 높아집니다.

- **그렇다면 컴파일 과정에서, final 키워드는 다르게 취급되나요?**
  - 네 컴파일 과정과 런타임 과정에서 다르게 취급됩니다. 컴파일러는 final로 선언된 상수를 상수풀에 저장하여 직접참조하도록 처리합니다.
  - 예를 들어 `final int x = 10` 은 바이트 코드에서 상수로 대체됩니다.
  - 메서드는 오버라이딩이 불가능 하므로 JIT 컴파일러가 메서드 호출을 인라인으로 최적화 할수있습니다.
  - 마지막으로 변경가능서잉 없으므로 런타임에서 관련된 검사코드를 생략합니다.

### 3. 변수는 어떤 것인가요?

- **참조형 변수에서 실제 값을 저장하지 않고 주소값을 저장하는 이유는 무엇인가요?**

- **그렇다면 기본형 변수는 스택 영역 내에 실제 값을 저장하는 이유는 무엇인가요?**

- **변수와 상수의 차이는 무엇인가요?**

### 4. 부동소수점이 무엇인가요?

- **부동소수점을 사용하면, 소수 계산 오차 문제가 사라지나요?**

- **자바에서 실수형 계산을 정확하게 하기 위해서는 어떻게 해야 하나요?**

- **그렇다면 BigDecimal 은 실수를 어떤 형태로 저장하나요?**

### 5. `==` 과 `equals` 의 차이점은 무엇인가요?

- **Object 의 `equals` 메서드는 어떻게 구현되어 있나요?**

- **아래의 코드는 어떤 결과가 나올까요? 이유를 설명해보세요.**

  ```java
  Integer a = new Integer(3);
  Integer b = new Integer(3);
  System.out.println(a==b);
  ```

- **그럼, `equals()` 와 `hashCode()` 에 대해 설명해 주세요.**

- **`hashCode()` 의 용도는 무엇인가요?**

- **본인이 `hashCode()` 를 정의해야 한다면, 어떤 점을 염두에 두고 구현할 것 같으세요?**

- **그렇다면 `equals()` 를 재정의 해야 할 때, 어떤 점을 염두에 두어야 하는지 설명해 주세요.**

- **만약 `equals()` 와 `hashCode()` 를 둘 다 재정의 했을 때, 객체의 주소값을 비교해야 한다는 상황이 온다면 어떻게 하나요?**

### 6. 다형성은 무엇인가요? 또 언제 활용할 수 있을까요?

### 7. 인터페이스와 추상클래스의 차이점은 무엇일까요?

- **왜 클래스는 단일 상속만 가능한데, 인터페이스는 2개 이상 구현이 가능할까요?**

- **인터페이스에서, `default method` 란 어떤 것인가요? 어떤 상황에서 주로 사용되나요?**

- **클래스A 가 인터페이스A, 인터페이스B 를 구현한다고 합시다. 만약 인터페이스A, 인터페이스B 에 동일한 시그니처를 가진 동일한 default method 가 있을 때, 다중 상속의 문제점이 발생하나요? 이것을 어떻게 해결하나요?**

### 8. A 라는클래스에 특정코드를 주고 싶을때, 상속과 조합의 차이는 무엇이고, 각각의 장점을 설명해주세요.

### 9. 리플렉션에 대해 설명해 주세요.

- **의미만 들어보면 리플렉션은 보안적인 문제가 있을 가능성이 있어보이는데, 실제로 그렇게 생각하시나요? 만약 그렇다면, 어떻게 방지할 수 있을까요?**

- **리플렉션을 언제 활용할 수 있을까요?**

### 10. static class와 static method를 비교해 주세요.

- **static 을 사용하면 어떤 이점을 얻을 수 있나요? 어떤 제약이 걸릴까요?**
- **컴파일 과정에서 static 이 어떻게 처리되는지 설명해 주세요.**

### 11. 자바에서 `new` 키워드를 사용하면 어떤 일이 일어나나요? 메모리 관점에서 자세히 설명해주세요.

### 12. 자바에서 스레드 풀(Thread Pool) 이란 어떤 것이고 언제 사용하나요?

### 13. Error 와 Exception 의 차이가 무엇인가요?

- **체크 예외와 언체크 예외의 차이는 무엇인가요?**

- **`OutOfMemoryError` 는 어떤 경우에 발생하나요?**

- **`StackOverflowError` 는 어떤 경우에 발생하나요?**

- **왜 체크 예외는 반드시 try-catch 문으로 처리해야고 언체크 예외는 처리하지 않아도 될까요?**

### 14. 자바에서 쓰레드를 생성하는 방법에는 어떤 것들이 있나요?

- **그렇다면 두 방법의 장단점은 무엇인가요?**

- **`Runnable` 인터페이스의 용도는 무엇인가요?**

- **왜 Thread 클래스의 `public static native Thread currentThread();` 는 static 으로 선언되어 있나요?**

- **쓰레드의 `start()` 과 `run()` 메서드는 어떤 차이가 있나요?**

- **아래 코드의 결과는 어떻게 될까요?**

  ```java
  class MyRunnable implements Runnable{
    public void run(){
      System.out.println("My Runnable is running");
      Thread currThread = Thread.currentThread();
      currThread.setName("thread in run method");
      System.out.println("Current thread in run : " + currThread.getName());
    }
  }

  class TestRunnable {
    public static void main(String[] args) {
      Thread thread = new Thread(new MyRunnable());
      thread.run();
      System.out.println("Current thread in main : " + Thread.currentThread().getName());
    }
  }
  ```

- **새로 생성된 쓰레드의 호출 스택은 언제 사라질까요?**

### 15. 쓰레드의 상태값에는 어떤 것들이 있나요?

- **`WAITING` 과 `BLOCKED` 의 차이는 무엇인가요?**

- **왜 `sleep()` 과 `yield()` 는 static 메서드인가요?**

- **`yield()` 과 `join()` 의 차이점은 무엇인가요?**

- **`sleep()` 과 `wait()` 의 차이점과 공통점은 무엇인가요?**

### 16. 쓰레드의 동기화는 무엇이며, 동기화에 사용되는 방법들은 어떤 것이 있나요?

- **`synchronized` 에 의한 방법은 무엇이며, 어떤 장단점이 있을까요?**

- **`wait()`와 `notify()` 를 이용한 방법은 무엇이며, 어떤 장단점이 있을까요?**

- **`java.util.concurrent.locks` 에 있는 Lock 과 Condition 은 위의 문제들을 어떻게 해결했나요?**

- **`volatile` 키워드는 어떻게 변수에 대한 읽기와 쓰기를 동기화하나요?**

### 17. `ConcurrentHashMap` 은 무엇이며 어떻게 thread-safe 를 보장하나요?

- **버킷이 비어있는 경우, 새로운 노드를 추가할 때는 어떻게 락을 걸지 않고 thread-safe 를 보장할 수 있나요?**

### 18. 함수형 프로그래밍은 무엇이며, 왜 필요한가요?

- **함수형 프로그래밍의 특징을 설명해주세요.**

- **자바에서는 어떻게 함수형 프로그래밍을 할 수 있나요?**

- **`@FunctionalInterface` 어노테이션의 역할은 무엇인가요?**

- **람다식과 함수형 인터페이스의 관계는 무엇인가요?**

- **람다표현식과 익명클래스의 차이는 무엇인가요?**

- **자바에서 미리 함수형 인터페이스를 정의해놓은 이유는 무엇인가요?**

### 19. 자바에서 I/O가 느린이유는 무엇인가요?

- **운영체제에서 I/O는 어떻게 동작하나요?**

- **자바 IO 패키지가 OS의 I/O 보다 훨씬 느린 이유는 무엇인가요?**

- **자바에서 NIO 패키지는 왜 IO 패키지에 비해 속도가 빠른가요?**

- **그러면 IO 가 무조건 나쁜 것일까요?**
