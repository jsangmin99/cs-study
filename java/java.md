## Java

<details>
<summary>📚 공부한 자료</summary>

- 자바의 정석

</details>

### 1. JVM이 정확히 무엇이고, 어떤 기능을 하는지 설명해 주세요. ⭐️
  - 자바 가상 머신은 자바와 운영체제 사이에서 중개자 역할을 합니다. 따라서 운영체제와 상관없이 독립적으로 실행할수있다는 장점이 있습니다.
  - 자바 소스코드는 먼저 바이트 코드로 변환이되고 JVM 위에서 실행됩니다.
  - 주요 기능은 메모리 관리와 가비지 컬렉터가 있습니다.
  ---
- **그럼, 자바 말고 다른 언어는 JVM 위에 올릴 수 없나요?**
  - 올릴수 있습니다. Kotlin, Scala, Groovy라는 언어도 JVM 위에서 실행시킬수 있습니다.

- **반대로 JVM 계열 언어를 일반적으로 컴파일해서 사용할 순 없나요?**
  - 보통 JVM컴파일러를 사용하여 컴파일을 합니다. 하자면 GraalVM 을 사용하여 다른 언어들을 JVM 바이트 코드로변환하여 사용할수있습니다.
  - 코틀린의 경우 Kotlin Native 컴파일러를 사용하여 기계어로 컴파일할 수 있다.
  - 그러나 JVM은 바이트코드를 실행하는데 최적화되어 있으므로 기계어로 컴파일하는 것이 권장되지 않는다.

- **JVM과 내부에서 실행되고 있는 프로그램은 부모 프로세스 - 자식 프로세스 관계를 갖고 있다고 봐도 무방한가요?**
  - JVM은 하나의 독립적인 프로세스이며, 내부에서 동작하는 자바 애플리케이션은 스레드를 사용하여 처리합니다.
  - 따라서 부모 프로세스 - 자식 프로세스 관계가 아니라 단일 프로세스 - 스레드 관계이다.


- **Java bytecode란 무엇인가요?**
  - Java 바이트코드는 자바 소스 코드를 컴파일한 결과물로 JVM에서 실행 가능한 중간 언어입니다. 
  - 자바 컴파일러는 자바 소스 코드를 바이트코드로 변환하여 .class 파일로 저장합니다. 
  - 이 바이트코드는 JVM이 이해할 수 있는 형식으로 운영체제에 독립적인 실행 환경을 제공합니다.

- **그렇다면 Java는 컴파일 언어일까요, 인터프리터 언어일까요?**
  - 자바는 컴파일과 인터프리터의 혼합형 언어입니다 자바는 먼저 자바 소스 코드를 바이트코드로 컴파일하고 이후 JVM이 그 바이트코드를 인터프리터 방식으로 실행합니다

- **JVM의 동작 방식에 대해 간단하게 설명해주세요.**
  1. 자바 소스코드를 바이트 코드로 변환
  2. 로드: JVM은 자바 바이트코드를 메모리에 로드합니다.
  3. 실행: JVM은 바이트코드를 해석하고 실행합니다. 이때 JIT(Just-In-Time) 컴파일러가 바이트코드를 네이티브 코드로 변환하여 실행 성능을 최적화할 수 있습니다.

- **JVM의 구조에 대해 설명해주세요.**
  - 클래스 로더: 바이트코드 파일을 JVM 메모리로 로드합니다.
  - 실행 엔진: 바이트코드를 실행하며, 인터프리터 방식 또는 JIT 컴파일러를 통해 실행합니다.
  - 런타임 데이터 영역: JVM이 실행 중인 프로그램에 필요한 데이터를 저장하는 메모리 영역입니다.
  - 가비지 컬렉션: 메모리 관리 시스템으로, 더 이상 사용되지 않는 객체를 자동으로 제거합니다.

- **JVM의 Runtime Data Area 영역은 무엇인가요?**
  - JVM의 런타임 데이터 영역은 프로그램이 실행될 때 사용하는 메모리 영역입니다.
    - 메소드 영역: 클래스 관련 데이터(클래스의 구조, 상수, 메소드 등)를 저장합니다.
    - 힙 영역: 객체를 저장하는 공간으로, 가비지 컬렉션이 관리합니다.
    - 스택 영역: 각 스레드마다 별도의 스택이 할당되며, 메서드 호출 시 로컬 변수와 파라미터가 저장됩니다.
    - PC 레지스터: 현재 실행 중인 명령어의 주소를 추적합니다.
    - 네이티브 메소드 스택: 네이티브 메소드를 실행하는 데 사용되는 스택입니다.

- **JVM Stack 과 Heap 영역의 가장 큰 차이점은 무엇인가요?**
  - 메모리 관리 입니다.
  - 스택(Stack): 메서드 호출 시 생성되는 로컬 변수와 메서드 정보를 저장합니다. 각 스레드마다 독립적인 스택을 가지고 있으며, 메서드가 종료되면 자동으로 할당된 메모리가 해제됩니다.
  - 힙(Heap): 객체와 배열을 저장하는 영역으로, JVM에서 가비지 컬렉터에 의해 관리됩니다. 스택과 달리, 힙의 객체는 메서드가 종료되어도 사라지지 않습니다.

- **만약 두 개의 스레드가 동시에 힙에 있는 메모리에 접근할 때 동시성 문제가 생길 수 있습니다. 구체적인 예시로는 어떤 것이 있을까요?**
  ```java
  public class Main {
    private int count = 0;

    public void increment() {
        count++;
    }
  }
  ```
  - increment를 여러 쓰레드에서 실행 시킬때 동시성 문제로 값이 정확하게 증가하지 않을 수도 있습니다.

- **스레드이 메서드별로 스택이 할당 되는데, 메서드가 종료되게 되면 그 메서드 안에서 아용된 로컬 변수가 쓸모 없어지기 때문에 메모리 해제가 되는데, 만약 메서드 안에서 선언한 변수가 참조형 타입인 경우에는 어떤 식으로 메모리가 사용되나요?**
  - 메서드 안에서 선언된 참조형 타입 변수는 스택에 저장되지만, 이 변수 자체는 참조를 저장하는 메모리 공간입니다. 객체는 힙 영역에 할당되며, 메서드가 종료되면 스택에서 참조가 제거됩니다. 만약 다른 곳에서 그 객체를 참조하고 있다면, 그 객체는 힙에 남아 있게 되며, 가비지 컬렉터에 의해 제거되지 않습니다.

- **Java 메모리 영역 중 Stack 과 Heap 에는 각각 어떤 것이 저장되나요?**
  - 스택(Stack): 각 스레드의 로컬 변수, 메서드 호출 정보, 파라미터 등이 저장됩니다.
  - 힙(Heap): 모든 객체와 배열이 저장됩니다.

- **기본형 데이터 타입과 참조형 데이터 타입의 실제 값은 각각 어느 영역에 저장되나요?**
  - 기본형 데이터 타입: 변수 자체의 값이 스택에 저장됩니다.
  - 참조형 데이터 타입: 객체의 참조 주소가 스택에 저장되며, 객체 자체는 힙에 저장됩니다.

- **그렇다면, `Person p = new Person()` 를 실행했을 때 `p` 와 `Person() 객체` 는 각각 어느 영역에 저장되나요?**
  - p는 스택에 저장되며, Person() 객체는 힙에 저장됩니다. p는 객체의 참조 주소를 가지고 있으며, 이 주소는 힙에 저장된 객체를 가리킵니다.

- **Java 메모리의 있는 스택 프레임은 메서드가 종료되면 사라집니다. 하지만 힙 영역에 있는 객체들은 메서드가 종료되도 메모리에 남아 있습니다. 왜 그럴까요?**
  - 스택 프레임은 메서드 호출과 관련된 정보만 저장되며, 메서드가 종료되면 해당 정보도 사라집니다. 그러나 힙에 저장된 객체들은 메서드 호출과 관계없이 계속 유지됩니다. 객체가 가비지 컬렉션에 의해 제거되지 않는 한 힙에 남아 있게 됩니다.


- **Static 영역과 Heap 영역의 공통점과 차이점은 무엇인가요?**
  - 공통점: 두 영역 모두 객체나 데이터를 저장할 수 있습니다.
  - 차이점:Static 영역은 클래스의 정적 변수와 정적 메서드를 저장하며, 프로그램 전체에서 공용으로 사용됩니다.힙은 동적 객체와 배열이 저장됩니다. 객체는 생성 시 동적으로 메모리 할당됩니다.


### 2. final 키워드를 사용하면, 어떤 이점이 있나요?
  - 불변성을 보장하서나 상속, 오버라딩을 제한하기 위해 사용됩니다.
  - 값이 변경되는것을 막기위해 불변성을 보장하거나ㅇ메서드나 클래스의 동작이 의도하지 않도록 사용을 막기위해 사용합니다.
  - JIT 컴파일러에 최적화 되어 final로 선언된 변수는 값이 변경되지 않으므로 컴파일러가 이값을 상수로 간주하고 최적화를 수행할수있습니ㅏㄷ. 그리고 메서드가 final 일경우에는 메서드 호출을 인라인으로 대체할 가능성이 높아집니다.

- **그렇다면 컴파일 과정에서, final 키워드는 다르게 취급되나요?**
  - 네 컴파일 과정과 런타임 과정에서 다르게 취급됩니다. 컴파일러는 final로 선언된 상수를 상수풀에 저장하여 직접참조하도록 처리합니다.
  - 예를 들어 `final int x = 10` 은 바이트 코드에서 상수로 대체됩니다.
  - 메서드는 오버라이딩이 불가능 하므로 JIT 컴파일러가 메서드 호출을 인라인으로 최적화 할수있습니다.
  - 마지막으로 변경가능서잉 없으므로 런타임에서 관련된 검사코드를 생략합니다.

### 3. 변수는 어떤 것인가요?
= 변수는 데이터를 저장하기 위해 명칭을 붙힌 메모리 공간입니다.
- **참조형 변수에서 실제 값을 저장하지 않고 주소값을 저장하는 이유는 무엇인가요?**
  -메모리의 효율성 때문입니다. 객체는 보통 크기가 크고 배열과 같이 복잡한 데이터 구조는 동적으로 확장할수있기 때문입니다. 값을 직접 저장하면 데이터의 크기에 따라 메모리를 많이 잡아 먹을수있습니다. 그리고 동일한 객체를 여러군데서 참조할수있는 형식 이기때문입니다.

- **그렇다면 기본형 변수는 스택 영역 내에 실제 값을 저장하는 이유는 무엇인가요?**
  - 기본형ㅂ데이터는 크기가 작고 고정되어 있어 메모리 접근이 빠릅니다.
  - 스택의 특징에따라 함수호출이 끝나면 메모리가 해제되기 때문에 메모리 해제가 효율적입니다.

- **변수와 상수의 차이는 무엇인가요?**
  - 변경가능성입니다. 변수는 값을 변경할수있지만 상수는 값을 변경할수 없습니다.
  
### 4. 부동소수점이 무엇인가요?
  - 컴퓨터에서 실수를 표현하는 방식중하나로 고정소수점과 부동 소수점이 있습니다.
    부동소수점은 유효숫자와 지ㄹ의 조합으로 저장을 하는데 이를 통해 큰숫자와 작은 숫자를 효율적으로 표현할수 있습니다. 다만 단점으로는 정밀성이 떨어짐니다. 0.1과 같은 소수는 이진수로 정확히 표현할수 없어 근사 값으로 저장됩니다.

- **부동소수점을 사용하면, 소수 계산 오차 문제가 사라지나요?**
  - 소수계산시 오차문제가 존재합니다. 이진표현을 할때 0.1 을 0.0000001100101010과 같이 근사값으로 저장 됩니다.
  - 또한 부동소수점의 비트수가 제한되어있어 많은 자릿수를 표현할수없습니다. 그리고 이런한 연산이 반복되다보면 미세한 오차가 누적되어 결과 값의 신뢰도가 떨어집니다.
- **자바에서 실수형 계산을 정확하게 하기 위해서는 어떻게 해야 하나요?**
  - BigDecimal 클래스를 사용하는것이 좋을것 같습니다. 다만 여기서 주의할점은 생성시 문저열로 초기화하는것이 중요합니다.

- **그렇다면 BigDecimal 은 실수를 어떤 형태로 저장하나요?**
  - 고정 소수점 방식으로 숫자를 그냥 저장한후 소수점의 위치를 나타냅니다. 예를 들어 123.01 이 있으면 12301 로 저장후 소수점의 위치 2 를 사용하여 저장합니다.

### 5. `==` 과 `equals` 의 차이점은 무엇인가요?
- '==' 은 참조 주소ㄱ을 비교하고 'equals' 는 객체의 값 자체를 비교합니다. 따라서 java 에서 == 동일한 메모리의 "위치" 인지 를 판단하고 equals 는 우리가 알고있는 값이 같은지를 비교합니다. 
- **Object 의 `equals` 메서드는 어떻게 구현되어 있나요?**
  ``` java
  public boolean equals(Object obj) {
    return (this == obj);
  }
  ```
  기본적으로는 주소를 비교합니다. 재정의 하지 않는다면 == 과 동일하게 작동합니다.
- **아래의 코드는 어떤 결과가 나올까요? 이유를 설명해보세요.**

  ```java
  Integer a = new Integer(3);
  Integer b = new Integer(3);
  System.out.println(a==b);
  ```
  결과는 false 입니다. 새로운 객체를 생성하는데 a와 b 는 서로 다를 주소를 가르키기 때문입니다.

- **그럼, `equals()` 와 `hashCode()` 에 대해 설명해 주세요.**
 - equlas() 는 논리적 동등한지를 비교하고 hasCode는 해시테이블 기반의 컬렉션에서 사용할수 있도록 고유한 정수값을 반환 합니다. 같은 객체라고 판단되는 두 객체는 반드시 같은 hashCode 값을 가집니다 그러나 다른 객체가 같은 hashCode 를 가질수는 있습니다. (해시테이블 특성상)
- **`hashCode()` 의 용도는 무엇인가요?**
  - 해시기반 컬랙션에서 객체를 빠르게 검색하거나 저장하기 위해 사용합니다. 해시테이블에서 객체를 버킷에 저장할때 hashCode를 사용하여 객체의 위치를 결정합니다.

- **본인이 `hashCode()` 를 정의해야 한다면, 어떤 점을 염두에 두고 구현할 것 같으세요?**
  - equals와의 일관성: equals()가 true를 반환하는 두 객체는 반드시 같은 hashCode를 반환해야 합니다.
  - 충돌 최소화: 가능한 서로 다른 객체는 다른 hashCode를 가지도록 설계해야 합니다.
  - 불변성: 객체가 변경되지 않는 한 동일한 hashCode 값을 반환해야 합니다.
  - 효율성: 해시 테이블에서의 성능을 위해 분산도가 높은 값을 생성해야 합니다.
- **그렇다면 `equals()` 를 재정의 해야 할 때, 어떤 점을 염두에 두어야 하는지 설명해 주세요.**
  - 대칭성: a.equals(b)가 true이면 b.equals(a)도 true여야 합니다.
  - 반사성: a.equals(a)는 항상 true여야 합니다.
  - 추이 성: a.equals(b)가 true이고, b.equals(c)가 true이면, a.equals(c)도 true여야 합니다.
  - 일관성: equals는 비교 대상의 상태가 변하지 않는 한 항상 동일한 결과를 반환해야 합니다.
  - null 비교: 어떤 객체와도 null.equals(x)는 false를 반환해야 합니다.
- **만약 `equals()` 와 `hashCode()` 를 둘 다 재정의 했을 때, 객체의 주소값을 비교해야 한다는 상황이 온다면 어떻게 하나요?**
  - 객체의 주소값을 직접 비교하고 싶을 경우, System.identityHashCode(obj)와 == 연산자를 사용합니다
    - System.identityHashCode(obj)는 객체의 메모리 주소 기반 해시코드를 반환합니다.
    - 직접 == 연산자를 사용하여 참조값을 비교할 수도 있습니다.
  ``` java
    Object obj1 = new Object();
    Object obj2 = new Object();

    System.out.println(obj1 == obj2); // 참조 비교
    System.out.println(System.identityHashCode(obj1) == System.identityHashCode(obj2)); // 해시코드 비교
  ```


### 6. 다형성은 무엇인가요? 또 언제 활용할 수 있을까요?

### 7. 인터페이스와 추상클래스의 차이점은 무엇일까요?

- **왜 클래스는 단일 상속만 가능한데, 인터페이스는 2개 이상 구현이 가능할까요?**

- **인터페이스에서, `default method` 란 어떤 것인가요? 어떤 상황에서 주로 사용되나요?**

- **클래스A 가 인터페이스A, 인터페이스B 를 구현한다고 합시다. 만약 인터페이스A, 인터페이스B 에 동일한 시그니처를 가진 동일한 default method 가 있을 때, 다중 상속의 문제점이 발생하나요? 이것을 어떻게 해결하나요?**

### 8. A 라는클래스에 특정코드를 주고 싶을때, 상속과 조합의 차이는 무엇이고, 각각의 장점을 설명해주세요.

### 9. 리플렉션에 대해 설명해 주세요.

- **의미만 들어보면 리플렉션은 보안적인 문제가 있을 가능성이 있어보이는데, 실제로 그렇게 생각하시나요? 만약 그렇다면, 어떻게 방지할 수 있을까요?**

- **리플렉션을 언제 활용할 수 있을까요?**

### 10. static class와 static method를 비교해 주세요.

- **static 을 사용하면 어떤 이점을 얻을 수 있나요? 어떤 제약이 걸릴까요?**
- **컴파일 과정에서 static 이 어떻게 처리되는지 설명해 주세요.**

### 11. 자바에서 `new` 키워드를 사용하면 어떤 일이 일어나나요? 메모리 관점에서 자세히 설명해주세요.

### 12. 자바에서 스레드 풀(Thread Pool) 이란 어떤 것이고 언제 사용하나요?

### 13. Error 와 Exception 의 차이가 무엇인가요?

- **체크 예외와 언체크 예외의 차이는 무엇인가요?**

- **`OutOfMemoryError` 는 어떤 경우에 발생하나요?**

- **`StackOverflowError` 는 어떤 경우에 발생하나요?**

- **왜 체크 예외는 반드시 try-catch 문으로 처리해야고 언체크 예외는 처리하지 않아도 될까요?**

### 14. 자바에서 쓰레드를 생성하는 방법에는 어떤 것들이 있나요?

- **그렇다면 두 방법의 장단점은 무엇인가요?**

- **`Runnable` 인터페이스의 용도는 무엇인가요?**

- **왜 Thread 클래스의 `public static native Thread currentThread();` 는 static 으로 선언되어 있나요?**

- **쓰레드의 `start()` 과 `run()` 메서드는 어떤 차이가 있나요?**

- **아래 코드의 결과는 어떻게 될까요?**

  ```java
  class MyRunnable implements Runnable{
    public void run(){
      System.out.println("My Runnable is running");
      Thread currThread = Thread.currentThread();
      currThread.setName("thread in run method");
      System.out.println("Current thread in run : " + currThread.getName());
    }
  }

  class TestRunnable {
    public static void main(String[] args) {
      Thread thread = new Thread(new MyRunnable());
      thread.run();
      System.out.println("Current thread in main : " + Thread.currentThread().getName());
    }
  }
  ```

- **새로 생성된 쓰레드의 호출 스택은 언제 사라질까요?**

### 15. 쓰레드의 상태값에는 어떤 것들이 있나요?

- **`WAITING` 과 `BLOCKED` 의 차이는 무엇인가요?**

- **왜 `sleep()` 과 `yield()` 는 static 메서드인가요?**

- **`yield()` 과 `join()` 의 차이점은 무엇인가요?**

- **`sleep()` 과 `wait()` 의 차이점과 공통점은 무엇인가요?**

### 16. 쓰레드의 동기화는 무엇이며, 동기화에 사용되는 방법들은 어떤 것이 있나요?

- **`synchronized` 에 의한 방법은 무엇이며, 어떤 장단점이 있을까요?**

- **`wait()`와 `notify()` 를 이용한 방법은 무엇이며, 어떤 장단점이 있을까요?**

- **`java.util.concurrent.locks` 에 있는 Lock 과 Condition 은 위의 문제들을 어떻게 해결했나요?**

- **`volatile` 키워드는 어떻게 변수에 대한 읽기와 쓰기를 동기화하나요?**

### 17. `ConcurrentHashMap` 은 무엇이며 어떻게 thread-safe 를 보장하나요?

- **버킷이 비어있는 경우, 새로운 노드를 추가할 때는 어떻게 락을 걸지 않고 thread-safe 를 보장할 수 있나요?**

### 18. 함수형 프로그래밍은 무엇이며, 왜 필요한가요?

- **함수형 프로그래밍의 특징을 설명해주세요.**

- **자바에서는 어떻게 함수형 프로그래밍을 할 수 있나요?**

- **`@FunctionalInterface` 어노테이션의 역할은 무엇인가요?**

- **람다식과 함수형 인터페이스의 관계는 무엇인가요?**

- **람다표현식과 익명클래스의 차이는 무엇인가요?**

- **자바에서 미리 함수형 인터페이스를 정의해놓은 이유는 무엇인가요?**

### 19. 자바에서 I/O가 느린이유는 무엇인가요?

- **운영체제에서 I/O는 어떻게 동작하나요?**

- **자바 IO 패키지가 OS의 I/O 보다 훨씬 느린 이유는 무엇인가요?**

- **자바에서 NIO 패키지는 왜 IO 패키지에 비해 속도가 빠른가요?**

- **그러면 IO 가 무조건 나쁜 것일까요?**
